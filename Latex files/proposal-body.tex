\section{Introduction}

A palindrome is a string that reads the same both ways.
Palindromic patterns appear in many research areas, from
formal language theory to molecular biology.

There are a lot of papers introducing algorithms and data structures
to facilitate different problems that involve palindromes.
One such data structure is EERTREE, a recently described
linear-sized palindromic tree introduced by Rubinchik \cite{RUBINCHIK2018249}.

In this project we aim to design at least one purely functional and
fully persistent version of a palindromic tree, implement it
in Haskell programming language and compare it
with other existing solutions. We are going to start with
a naive implementation and gradually arrive at an efficient
version, relying on some of the techniques described by
Okasaki \cite{Okasaki1998} for designing purely functional data structures.

We hope that purely functional variations will prove valuable
for some divide-and-conquer approaches to palindromic analysis.
We also believe that a fully persistent version might be useful
for comparative analysis of closely-related strings
(such as RNA string mutations).

\section{Work Plan}

\subsection{Iteration I (Feb 11 - Feb 25)}

Analyse EERTREE data structure closely.
Collect common palindrome-related problems.
Research alternative algorithms and data structures for those problems.
Investigate existing approaches to palindromic analysis.
Form a list of important operations on EERTREE
to compare for time and space complexity.

\subsection{Iteration II (Feb 25 - Mar 11)}

Propose a purely functional, fully persistent palindromic tree.
Analyse time and space complexities for the most important operations
(both worst-case and amortized).
Compare with the original palindromic tree.

\subsection{Iteration III (Mar 11 - Mar 25)}

Implement EERTREE and the purely functional palindromic tree.
Compare implementations on sample problems.
Analyse purely functional implementation performance.

\subsection{Iteration IV (Mar 25 - Apr 08)}

Investigate options to improve performance for
the purely functional palindromic tree.
Consider these options:

\begin{itemize}
  \item fusion/deforestation optimisations;
  \item cache-oblivious model optimizations;
  \item linked vs. vector-based implementations;
  \item asymptotic improvements via partial evaluation;
  \item optimisations for small alphabet strings.
\end{itemize}

\subsection{Iteration V (Apr 08 - Apr 22)}

Design a generalised interface to the data structure,
relying on parametric polymorphism and higher-order functions
to facilitate reusability.

\subsection{Iteration VI (Apr 22 - May 06)}

Finalise the project by creating a Cabal package complete with
examples, tests, code comments, documentation and, perhaps, a
formal verification.

\section{Iteration results}

\subsection{Iteration I}
During iteration I github repository\cite{khazhix} was created where all related to the topic materials were collected. In general this iteration was successful: the analysis of data structure revealed a lack of functionality, interesting problems was found and overview with comparison of similar approaches was made. Detailed results for this iteration can be found in separate pdf file\cite{khazhix1} in github repository.

\subsection{Iteration II}
During iteration II two sided tree (where merge operation might perform better than naive merge) and infinite tree (for persistency) were proposed. This iteration was ok: several ideas and thoughts were proposed, but not deeply studied (no set operation description and complexities are not analyzed). These issues can be fixed during next iteration as implementation can lead to better understanding and reasoning. Detailed results for this iteration can be found in separate pdf file\cite{khazhix2} in github repository.

\subsection{Iteration III}
During iteration III ideas from previous iteration were implemented: infinite tree, double ended (two sided) tree and merge operation. Also new observations emerged: better merge approach and interesting fact about average maximum palindrome suffix length. This iteration was not as good as
expected: due to midterm examinations (or bad time management) there were no comparison of implementations (original vs purely functional) and performances are not analyzed. Detailed results for this iteration can be found in separate pdf file\cite{khazhix3} in github repository.

\subsection{Iteration IV}
During iteration IV idea from previous iteration was implemented: new merge algorithm for double ended tree. Also new observations emerged: better (proper) merge approach and splitting list for tree palindromes into two list of palindromes for that proper merge. This iteration was ok: more optimized ideas investigated but not all options was analyzed (fusion/deforestation optimization, cache-oblivious model optimization) due to lack of knowledge in this field. Detailed results for this iteration can be found in separate pdf file\cite{khazhix4} in github repository.

\subsection{Iteration V}
During iteration V idea from previous iteration was implemented: proper merge algorithm for double ended tree. This iteration was ok: in fact, same interface was used throughout previous iterations and it was convenient enough.
Detailed results for this iteration can be found in separate pdf file\cite{khazhix5} in github repository.

\subsection{Iteration VI}
Finalization of project was during iteration VI. This iteration was ok: in fact, some comments/test were written during previous iterations. Cabal package is not formed due to lack of experience in proper package formation. Also paper work in progress.
Detailed results for this iteration can be found in separate pdf file\cite{khazhix6} in github repository.