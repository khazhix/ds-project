\section{2 sided tree}
As the original tree holds only maximum palindrome suffix, we can only append a new symbol. But what if we want to add a new symbol at the beginning? To allow that we can add maximum palindrome prefix support. So we might need to keep track of max prefixes, but as palindrome is symmetric, maximum palindrome suffix of palindrome is maximum palindrome prefix as well. Thus we can simply keep information about maximum palindrome prefix of processed string (as we keep information about maximum suffix). So no major memory usage is added, only one more entry.

This extension allows us merge two eertrees more efficient than simple naive approach (adding symbol by symbol from string of eertree$_2$ to eerteee$_1$). Let's consider example: $"abbabba" + "bbbab"$.
Palindromes of concatenated string includes all processed palindromes of both strings and new ones. It's pretty obvious that new palindromes can be found somewhere around joint of two strings. 

There are three cases: \begin{enumerate*}
  \item center of new palindromes is joint
  \item center of new palindromes is max suffix (and/or its max suffixes) of first string
  \item center of new palindromes is max prefix (and/or its max prefixes) of second string.
\end{enumerate*}
For current example blue represents max palindrome prefix, red represents max palindrome suffix and black represents symbols that we are checking:
$"\mathunderline{red}{abb\mathunderline{red}{abb\mathunderline{red}{a}}}" + "\mathunderline{blue}{\mathunderline{blue}{\mathunderline{blue}{b}b}b}ab"$
\begin{enumerate}
\item $"abbabb\underline{a}" + "\underline{b}bbab"$, $"ab"$ is not a palindrome, stop here.
\item $\underline{\ \ }"\mathunderline{red}{abb\mathunderline{red}{abb\mathunderline{red}{a}}}" + "\underline{b}bbab"$, nothing to compare, moving to next max suffix \\
$"ab\underline{b}\mathunderline{red}{abb\mathunderline{red}{a}}" + "\underline{b}bbab"$, $"babbab"$ is potential new palindrome, expanding more\\
$"a\underline{bb}\mathunderline{red}{abb\mathunderline{red}{a}}" + "\underline{bb}bab"$, $"bbabbabb"$ is potential new palindrome, expanding more\\
$"\underline{abb}\mathunderline{red}{abb\mathunderline{red}{a}}" + "\underline{bbb}ab"$, $"abbabbabbb"$ is not a palindrome, moving to next max suffix.\\
$"abbab\underline{b}\mathunderline{red}{a}" + "\underline{b}bbab"$, $"bab"$ is potential new palindrome, expanding more\\
$"abba\underline{bb}\mathunderline{red}{a}" + "\underline{bb}bab"$, $"bbabb"$ is potential new palindrome, expanding more\\
$"abb\underline{abb}\mathunderline{red}{a}" + "\underline{bbb}ab"$, $"abbabbb"$ is not a palindrome, stop here.
\item 
$"abbabb\underline{a}" + "\mathunderline{blue}{\mathunderline{blue}{\mathunderline{blue}{b}b}b}\underline{a}b"$, $"abbba"$ is potential new palindrome, expanding more\\
$"abbab\underline{ba}" + "\mathunderline{blue}{\mathunderline{blue}{\mathunderline{blue}{b}b}b}\underline{ab}"$, $"babbbab"$ is potential new palindrome, expanding more\\
$"abba\underline{bba}" + "\mathunderline{blue}{\mathunderline{blue}{\mathunderline{blue}{b}b}b}\underline{ab\ \ }"$, nothing to compare, moving to next max prefix \\
$"abbabb\underline{a}" + "\mathunderline{blue}{\mathunderline{blue}{b}b}\underline{b}ab"$, $"abbb"$ is not a palindrome, moving to next max prefix\\
$"abbabb\underline{a}" + "\mathunderline{blue}{b}\underline{b}bab"$, $"abb"$ is not a palindrome, stop here\\
\end{enumerate}
All found palindromes are added to the a tree. Max palindrome suffix of merged tree is max palindrome suffix of second string. If one of new found palindromes includes whole second string, it becomes max palindrome suffix. And visa-versa max palindrome prefix of merged tree is max palindrome prefix of first string. If one of new found palindromes includes whole first string, it becomes max palindrome prefix. Thus max suffix can be same sequence as max prefix. Nabludenie! Also number of palindromes which includes whole string is exactly one?
\section{Infinite tree}
Some problems does not require information about original string as an output, just raw palindromes information. For some alphabet $\sigma$ we can simply generate palindromes of length $n$. The number of palindromes of length $n$ will be $g(n, \sigma)$ where 
$$g(n, \sigma) = \begin{cases}
\ \sqrt{\sigma^{n}} \cdot \sigma & n \ is \ odd\\
\ \sqrt{\sigma^{n}}   & n \ is \ even
\end{cases}$$
 That tree will represent all possible palindromes and their dependencies. So the number nodes of infinite tree for fixed alphabet will be $\sum_{n=1}^{\infty} g(n, \sigma)$. Here where haskell's lazy evaluation will come in handy. 

