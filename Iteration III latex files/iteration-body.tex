\section{Naive implementation of infinite tree}
Simple (with basic suffix links) infinite tree was implemented. Basically structure is represented by two root nodes for odd and even palindromes. Node contains length, palindrome (in a form of string), list of pairs (symbol, node) where nodes adjacent to current node by that symbol (edges list) and a link (node) to max palindrome suffix.  

Edges can be trivially defined. Link node is searched by value, to get that value we simply look up through all suffixes of current palindrome.

To visually check that it works we can print out ten top (lexicographically ordered)  palindromes of tree, print their relations and so on. 
Code for that implementation can be found in GitHub repository\cite{khazhix3}.



\section{String representation based on infinite tree}
Eertree from original work\cite{RUBINCHIK2018249} of some string $S$ is actually a subtree of infinite tree. To build that subtree we do pretty much the same, but instead of building tree, we will refer to infinite tree and simply append found node to list of palindromes.

To check that it works, we can calculate number of rich palindromes of length $n$ and compare it with actual sequence from OEIS \cite{oeisA216264}. A sequence of length $n$ is called rich if it contains, as subsequences, exactly $n$ distinct palindromes. That also shows that infinite tree is build properly (not only by observing, but using sequence).

Code for that implementation can be found in GitHub repository in older commits\cite{khazhix4}.

\section{Double ended tree}
Double ended tree is an extension of basic tree explained in previous iteration\cite{khazhix5} (which was called "two sided tree"). Remind that basic tree keeps information about maximum palindrome suffixes, that helps appending a new symbol. To allow prepend function we need to keep information maximum palindrome prefix.

That extension helps us to implement merge operation. That was also implemented a using merge algorithm described in previous iteration report and source code can be founded in GitHub repository \cite{khazhix3}. That was also checked by comparing palindromes of $merge(tree(S_1), tree(S_2))$ and $tree(S_1 + S_2)$ where $S_1, S_2$ are string.

\section{New merge algorithm for merging trees}
During this iteration new approach of merging was observed.
Previous merge approach was checking through all suffixes (maxSuffix, maxSuffix of maxSuffix, maxSuffix of maxSuffix of maxSuffix...) and same with prefixes. For example in case of string of form $"aaa\ldots aaa"$ number of suffixes (and prefixes) is length of that string. And for each suffix of first string (and prefix of second) we are looking for palindromes by expanding out of that suffix (or prefix). We will do a lot of checks.

Another approach comes from combining naive implementation (prepending/appending string to another string symbol by symbol) and fact that new palindromes are located around maxSuffix$_1$ and maxPrefix$_2$ ($_1$ can be read as "of first string"). In a simple way it can be described as followed (if we append to first string): do append and work with maxSuffix until maxSuffix$_{new}$ went beyond maxPrefix$_2$ and maxSuffix$_{new}$ $\not\supset$ maxPrefix$_2$.
As in previous algorithm we also add palindromes of second string to merged tree and update maxPrefix and maxSuffix.

In worst case it will operate as simple naive implementation with complexity $O(N)$. Also we can use fact from another Rubinchik's paper \cite{rubinchik2016number} that showed that random word of length $n$ contains, on expectation, $\Theta(\sqrt{n})$ distinct palindromic factors. So if length of first string is $n$ and length of second is $m$, on expectation, their concatenation gives us $\Theta(\sqrt{n + m})$ palindromes. From that we exclude palindromes that already processed separately. So $O(\sqrt{n + m})$ is complexity for average case and that is interesting for parallel computation of palindromes of chunks of some string. But it might be better.

\section{Observation on maxSuffix length}
We observed that average length of maximum palindromic suffix of a random string of length $n$ for alphabets of size $\sigma \geq 2$ is $\Theta(1)$. That gives some room for optimization (e.g. logic branch). For example appending can be done $\Theta(1)$ on average and $O(\log n)$ worst case.